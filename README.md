# SibFUAchive
Выполнено: Соловьев Александр КИ 22/16 1Б
___
# Запуск
Необходимо открыть проект в любом компиляиторе с установленной библиотекой JDK 19 и JavaFX 21 и запустить класс Runnner.
___
# Соблюдение принципов SOLID

## AddNewPacController
Этот класс представляет контроллер для пользовательского интерфейса, связанного с добавлением нового пакета (предположительно, в каком-то приложении). Давайте рассмотрим его подробно с точки зрения принципов SOLID:

+ ### Принцип единственной ответственности (Single Responsibility Principle - SRP):
Описание: Класс AddNewPacController отвечает за управление взаимодействием с пользовательским интерфейсом и обработку действий, связанных с добавлением нового пакета.
Соблюдение SRP: Весь код класса связан с интерфейсом и действиями, связанными с добавлением нового пакета. Он не занимается другими аспектами, такими как обработка данных или управление состоянием.

+ ### Принцип открытости/закрытости (Open/Closed Principle - OCP):
#### Описание: 
Класс AddNewPacController должен быть открыт для расширения и закрыт для модификации.

#### Соблюдение OCP: 
В данном контексте класс не расширяется через наследование и не использует полиморфизм. В связи с этим, он не является ярким примером соблюдения OCP. Однако, изменения в логике добавления пакета могут быть внесены, не затрагивая другие части системы.

+ ###  Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):
#### Описание: 
Классы-потомки должны быть взаимозаменяемы с их базовыми классами.
#### Соблюдение LSP: 
В данном случае нет наследования, но если бы были созданы подклассы, они должны были бы взаимозаменяемы с базовым контроллером, сохраняя при этом функциональность.

+ ### Принцип интерфейсов (Interface Segregation Principle - ISP):
#### Описание: 
Клиенты не должны зависеть от интерфейсов, которые они не используют.
#### Соблюдение ISP: 
В данном классе нет явного использования интерфейсов, поэтому принцип соблюдается.

+ ### Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
#### Описание: 
Зависимости должны строиться относительно абстракций, а не деталей реализации.
#### Соблюдение DIP: 
В классе видим использование фреймворка JavaFX (FXML и аннотации @FXML), что является деталями реализации. Однако, это не противоречит принципу, так как это стандартная практика для JavaFX-контроллеров.
___

## AddTaskController
Этот класс представляет контроллер для пользовательского интерфейса, связанного с добавлением новой задачи. Давайте рассмотрим его подробно с точки зрения принципов SOLID:

+ ### Принцип единственной ответственности (Single Responsibility Principle - SRP):
#### Описание:
Класс AddTaskController отвечает за управление взаимодействием с пользовательским интерфейсом и обработку действий, связанных с добавлением новой задачи.

#### Соблюдение SRP:
Весь код класса связан с интерфейсом и действиями, связанными с добавлением новой задачи. Он не занимается другими аспектами, такими как обработка данных или управление состоянием.

+ ### Принцип открытости/закрытости (Open/Closed Principle - OCP):
#### Описание:
Класс AddTaskController должен быть открыт для расширения и закрыт для модификации.

#### Соблюдение OCP:
В данном контексте класс не расширяется через наследование и не использует полиморфизм. В связи с этим, он не является ярким примером соблюдения OCP. Однако, изменения в логике добавления задачи могут быть внесены, не затрагивая другие части системы.

+ ### Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):
#### Описание:
Классы-потомки должны быть взаимозаменяемы с их базовыми классами.

#### Соблюдение LSP:
В данном случае нет наследования, но если бы были созданы подклассы, они должны были бы взаимозаменяемы с базовым контроллером, сохраняя при этом функциональность.

+ ### Принцип интерфейсов (Interface Segregation Principle - ISP):
#### Описание:
Клиенты не должны зависеть от интерфейсов, которые они не используют.

#### Соблюдение ISP:
В данном классе нет явного использования интерфейсов, поэтому принцип соблюдается.

+ ### Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
#### Описание:
Зависимости должны строиться относительно абстракций, а не деталей реализации.

#### Соблюдение DIP:
В классе видим использование фреймворка JavaFX (FXML и аннотации @FXML), что является деталями реализации. Однако, это не противоречит принципу, так как это стандартная практика для JavaFX-контроллеров.
___

## AddTaskTodayController
Этот класс представляет контроллер для пользовательского интерфейса, связанного с добавлением новой задачи на текущий день. Давайте рассмотрим его подробно с точки зрения принципов SOLID:

+ ### Принцип единственной ответственности (Single Responsibility Principle - SRP):
#### Описание:
Класс AddTaskTodayController отвечает за управление взаимодействием с пользовательским интерфейсом и обработку действий, связанных с добавлением новой задачи на текущий день.

#### Соблюдение SRP:
Весь код класса связан с интерфейсом и действиями, связанными с добавлением новой задачи на сегодня. Он не занимается другими аспектами, такими как обработка данных или управление состоянием.

+ ### Принцип открытости/закрытости (Open/Closed Principle - OCP):
#### Описание:
Класс AddTaskTodayController должен быть открыт для расширения и закрыт для модификации.

#### Соблюдение OCP:
В данном контексте класс не расширяется через наследование и не использует полиморфизм. В связи с этим, он не является ярким примером соблюдения OCP. Однако, изменения в логике добавления задачи на сегодня могут быть внесены, не затрагивая другие части системы.

+ ### Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):
#### Описание:
Классы-потомки должны быть взаимозаменяемы с их базовыми классами.

#### Соблюдение LSP:
В данном случае нет наследования, но если бы были созданы подклассы, они должны были бы взаимозаменяемы с базовым контроллером, сохраняя при этом функциональность.

+ ### Принцип интерфейсов (Interface Segregation Principle - ISP):
#### Описание:
Клиенты не должны зависеть от интерфейсов, которые они не используют.

#### Соблюдение ISP:
В данном классе нет явного использования интерфейсов, поэтому принцип соблюдается.

+ ### Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
#### Описание:
Зависимости должны строиться относительно абстракций, а не деталей реализации.

#### Соблюдение DIP:
В классе видим использование фреймворка JavaFX (FXML и аннотации @FXML), что является деталями реализации. Однако, это не противоречит принципу, так как это стандартная практика для JavaFX-контроллеров.
___

## CitataController
Этот класс представляет контроллер для пользовательского интерфейса, отображающего случайную цитату. Давайте рассмотрим его подробно с точки зрения принципов SOLID:

+ ### Принцип единственной ответственности (SRP):
#### Описание: 
Класс CitataController отвечает за управление взаимодействием с пользовательским интерфейсом и отображение случайной цитаты.
#### Соблюдение SRP: 
Класс сосредоточен на задачах, связанных с интерфейсом и отображением цитаты. Он не занимается другими аспектами, такими как обработка данных или управление состоянием.

+ ### Принцип открытости/закрытости (OCP):
#### Описание: 
Класс CitataController должен быть открыт для расширения и закрыт для модификации.
#### Соблюдение OCP:
Класс не сильно зависит от конкретных реализаций и может быть легко расширен для изменений в отображении цитат.

+ ### Принцип подстановки Барбары Лисков (LSP):
#### Описание: 
Классы-потомки должны быть взаимозаменяемы с их базовыми классами.
#### Соблюдение LSP:
В данном случае нет явного использования наследования, и класс не содержит элементов, которые могли бы быть переопределены в потомках.

+ ### Принцип интерфейсов (ISP):
#### Описание: 
Клиенты не должны зависеть от интерфейсов, которые они не используют.
#### Соблюдение ISP: 
Класс не использует интерфейсы, и его функциональность сосредоточена на конкретных элементах пользовательского интерфейса.

+ ### Принцип инверсии зависимостей (DIP):
#### Описание: 
Зависимости должны строиться относительно абстракций, а не деталей реализации.
#### Соблюдение DIP: 
Класс не содержит явных зависимостей от конкретных реализаций, и его функциональность построена в соответствии с принципами JavaFX.
___

## HelloApplication
+ ### Принцип единственной ответственности (SRP):
#### Описание: 
Класс HelloApplication отвечает за запуск JavaFX-приложения и инициализацию его основных компонентов.
#### Соблюдение SRP: 
Класс фокусируется на задачах, связанных с инициализацией пользовательского интерфейса, не вмешиваясь в бизнес-логику.

+ ### Принцип открытости/закрытости (OCP):
#### Описание: 
Класс HelloApplication может быть расширен для изменения интерфейса и поведения приложения, не затрагивая основной логики.

#### Соблюдение OCP: 
Класс можно легко расширить, например, добавив новые компоненты интерфейса, не изменяя его основной структуры.

+ ### Принцип подстановки Барбары Лисков (LSP):
#### Описание:
В данном случае отсутствует явное наследование, и класс не взаимодействует с потомками.
#### Соблюдение LSP: 
Класс не взаимодействует с наследниками, и его функциональность не предполагает взаимозаменяемость через наследование.

+ ### Принцип интерфейсов (ISP):
#### Описание: 
Класс HelloApplication не использует интерфейсы, и его функциональность связана с конкретной реализацией JavaFX-приложения.
#### Соблюдение ISP: 
Класс не предполагает разделение интерфейсов, и его функциональность сосредоточена на конкретных задачах JavaFX.

+ ### Принцип инверсии зависимостей (DIP):
#### Описание: 
Класс HelloApplication зависит от библиотеки JavaFX, что соответствует принципу использования абстракций, а не деталей реализации.
#### Соблюдение DIP: 
Зависимости построены относительно абстракций, и класс использует стандартные средства JavaFX.
___

## HelloController
+ ### Принцип единственной ответственности (SRP):
#### Описание: 
Класс HelloController управляет взаимодействием пользователя с графическим интерфейсом и обработкой событий.
#### Соблюдение SRP: 
Класс фокусируется на конкретных задачах, связанных с обработкой событий и управлением элементами интерфейса.

+ ### Принцип открытости/закрытости (OCP):
#### Описание: 
Класс HelloController может быть расширен для добавления новых функций или изменения логики обработки событий.
#### Соблюдение OCP: 
Класс не препятствует расширению, и новая функциональность может быть добавлена без изменения существующего кода.

+ ### Принцип подстановки Барбары Лисков (LSP):
#### Описание: 
В классе HelloController отсутствует явное наследование и взаимодействие с потомками.
#### Соблюдение LSP: 
ласс не содержит элементов, которые могли бы быть взаимозаменяемыми через наследование.

+ ### Принцип интерфейсов (ISP):
#### Описание: 
Класс HelloController не использует интерфейсы, и его функциональность сосредоточена на обработке событий и управлении элементами интерфейса.
#### Соблюдение ISP: 
В данном контексте класс не предполагает использование интерфейсов, и его функциональность достаточно специфична.

+ ### Принцип инверсии зависимостей (DIP):
#### Описание: 
Класс HelloController содержит зависимость от библиотеки JavaFX для обработки графического интерфейса.
#### Соблюдение DIP: 
Зависимость построена относительно абстракций, и класс использует стандартные средства JavaFX.
___

## Runner
+ ### Принцип единственной ответственности (SRP):
#### Описание: 
Класс Runner выполняет единственную задачу - вызов метода main для запуска приложения.
#### Соблюдение SRP: 
Класс сфокусирован на задаче инициализации и запуска приложения, не содержащей дополнительной функциональности.

+ ### Принцип открытости/закрытости (OCP):
#### Описание: 
Класс Runner не предоставляет точек расширения или модификации и является статическим запускателем.
#### Соблюдение OCP:
Класс не является типичным примером соблюдения принципа OCP, так как его структура и функциональность ограничены вызовом main.

+ ### Принцип подстановки Барбары Лисков (LSP):
#### Описание: 
Класс Runner не взаимодействует с классами-потомками или наследниками.
#### Соблюдение LSP: 
Класс не содержит элементов, которые могли бы повлиять на взаимозаменяемость через наследование.

+ ### Принцип интерфейсов (ISP):
#### Описание: 
Класс Runner не использует интерфейсы, и его функциональность сводится к вызову main.
#### Соблюдение ISP: 
Класс не предполагает использование интерфейсов, и его задача является достаточно конкретной.

+ ### Принцип инверсии зависимостей (DIP):
#### Описание: 
Класс Runner не содержит явных зависимостей от внешних библиотек или фреймворков.
#### Соблюдение DIP:
Зависимости отсутствуют, что соответствует принципу инверсии зависимостей.
___
# Паттерн: Наблюдатель (Observer)
Этот паттерн позволяет оповещать зависимые объекты об изменениях в другом объекте. В случае TO-DO приложения, наблюдатели могут быть уведомлены о добавлении новой задачи, ее завершении или изменении статуса.

```Java
private String name;
private String date;

public String getName() {
    return name;
}

public String getDate() {
    return date;
}

private String formatDate(LocalDate date) {
    // Define a date formatter
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy");

    // Format the date as a string
    return date.format(formatter);
}

@FXML
void initialize() {
    cancel_button.setOnAction(new EventHandler<ActionEvent>() {
        @Override
        public void handle(ActionEvent event) {
            cancel_button.getScene().getWindow().hide();
        }
    });

    create_button.setOnAction(new EventHandler<ActionEvent>() {
        @Override
        public void handle(ActionEvent event) {
            if (aim_imput.getText().isEmpty()) {
                name = null;
            } else {
                name = aim_imput.getText();
            }

            LocalDate selectedDate = date_input.getValue();
            if (selectedDate != null) {
                date = formatDate(selectedDate);
            } else {
                date = "Нет даты";
            }
            create_button.getScene().getWindow().hide();
        }
    });
}
```
___
# Паттерн которые не стоило бы применять: Паттерн Заместитель (Proxy) 
Заместитель предоставляет замену другого объекта для управления доступом к нему. Если в TO-DO приложении нет необходимости в контроле доступа к задачам или спискам, то использование заместителя может быть излишним.
В общем, использование паттерна Заместитель оправдано, когда есть конкретные потребности, такие как отложенная инициализация, управление доступом или другие сложные сценарии. В данном же контексте простота и прозрачность кода могут быть более важными, чем введение дополнительных абстракций.



